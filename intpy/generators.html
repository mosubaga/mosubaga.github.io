<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Intermediate Python - Generators</title>
  <link rel="stylesheet" href="css/styles.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" />
</head>
<body>
  <nav>
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="oop.html">OOP</a></li>
      <li><a href="collections.html">Collections</a></li>
      <li><a href="advfunctions.html">Functions</a></li>
      <li><a href="generators.html">Generators</a></li>
      <li><a href="concurrency.html">Concurrency</a></li>
      <li><a href="async.html">Async</a></li>
    </ul>
  </nav>

  <main>
    <section>
      <h1>Generators and Iterators</h1>
      <p>
        Generators produce values lazily using <code>yield</code>. They are ideal for large
        datasets, streaming pipelines, and infinite sequences because they compute values
        on demand instead of storing them in memory.
      </p>
    </section>

    <section>
      <h2>Iterator Protocol</h2>
      <div class="card">
        <h3>Iterables vs Iterators</h3>
        <p>
          An iterable returns an iterator via <code>iter()</code>. An iterator implements
          <code>__next__</code> and raises <code>StopIteration</code> when done.
        </p>
        <pre><code class="language-python">items = [1, 2, 3]
it = iter(items)

print(next(it))  # 1
print(next(it))  # 2
print(next(it))  # 3
# next(it) would raise StopIteration</code></pre>
      </div>

      <div class="card">
        <h3>Generator Functions</h3>
        <p>
          A function becomes a generator when it uses <code>yield</code>. Each yield pauses
          execution, remembering state between calls.
        </p>
        <pre><code class="language-python">def countdown(n):
    while n &gt; 0:
        yield n
        n -= 1

for value in countdown(3):
    print(value)
# 3 2 1</code></pre>
      </div>

      <div class="card">
        <h3>Generator Expressions</h3>
        <p>
          Generator expressions are compact, lazy equivalents of list comprehensions.
        </p>
        <pre><code class="language-python">squares = (n * n for n in range(5))
print(list(squares))  # [0, 1, 4, 9, 16]</code></pre>
      </div>
    </section>

    <section>
      <h2>Why Use Generators?</h2>
      <table>
        <thead>
          <tr>
            <th>Scenario</th>
            <th>List</th>
            <th>Generator</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Large file</td>
            <td>Loads all lines</td>
            <td>Streams line by line</td>
          </tr>
          <tr>
            <td>Infinite series</td>
            <td>Impossible</td>
            <td>Works lazily</td>
          </tr>
          <tr>
            <td>Pipeline</td>
            <td>Materializes each step</td>
            <td>Composes efficiently</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h2>Advanced Generator Features</h2>
      <div class="card">
        <h3>Send Values Into Generators</h3>
        <p>
          Generators can receive values via <code>send</code>, enabling coroutines and
          stateful pipelines.
        </p>
        <pre><code class="language-python">def running_total():
    total = 0
    while True:
        value = yield total
        if value is None:
            break
        total += value

gen = running_total()
print(next(gen))      # 0
print(gen.send(5))    # 5
print(gen.send(3))    # 8
# gen.send(None) would stop the generator</code></pre>
      </div>

      <div class="card">
        <h3>yield from</h3>
        <p>
          <code>yield from</code> delegates to another generator, simplifying nested iteration.
        </p>
        <pre><code class="language-python">def letters():
    yield "a"
    yield "b"

def numbers():
    yield 1
    yield 2

def combined():
    yield from letters()
    yield from numbers()

print(list(combined()))  # ['a', 'b', 1, 2]</code></pre>
      </div>

      <div class="card">
        <h3>Generator Cleanup</h3>
        <p>
          Use <code>try/finally</code> to ensure cleanup when a generator is closed early.
        </p>
        <pre><code class="language-python">def safe_reader(lines):
    try:
        for line in lines:
            yield line.strip()
    finally:
        print("cleanup")

for line in safe_reader([" a ", " b "]):
    print(line)
    break
# cleanup</code></pre>
      </div>
    </section>

    <section>
      <h2>Mini Example</h2>
      <table>
        <thead>
          <tr>
            <th>Concept</th>
            <th>Snippet</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Basic generator</td>
            <td><code>def gen(): yield 1</code></td>
          </tr>
          <tr>
            <td>Expression</td>
            <td><code>(x*x for x in data)</code></td>
          </tr>
          <tr>
            <td>Delegation</td>
            <td><code>yield from other()</code></td>
          </tr>
          <tr>
            <td>Send</td>
            <td><code>gen.send(value)</code></td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h2>Sample Code: Streaming Pipeline</h2>
      <pre><code class="language-python">def read_numbers():
    for i in range(1, 6):
        yield i

def square(nums):
    for n in nums:
        yield n * n

def filter_even(nums):
    for n in nums:
        if n % 2 == 0:
            yield n

pipeline = filter_even(square(read_numbers()))
print(list(pipeline))  # [4, 16]</code></pre>
    </section>
  </main>

  <footer>
    <p>Generators make data pipelines memory-efficient and expressive.</p>
  </footer>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</body>
</html>
